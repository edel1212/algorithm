# Do-it 알고리즘 테스트

## 1 ) 시간 복잡도
- 참고 : [링크](https://github.com/edel1212/algorithm/tree/main/time-complexity)

## 2 ) 놓치기 쉬운 중요 개념

### 2 - 1 ) 의도치 않은 결과 값이 음수 일 경우 [ OverFlow ]
- 로직 자체에서 문제가 없다면 **자료형**을 꼭 확인하자 대부분의 문제는 자료형에서 발생함
  - int : -21억 ~ 21억 약 (±21억)
  - long : -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (약 ±9.22 × 10¹⁸)

### 2 - 2 ) 시간 초과
- 시간 초과가 날 경우 **적절한 시간 복잡도를 사용**하여 처리한다 ( 1초 -> 1억 연산 기준으로 빅오 표기법에 대입하여 처리 )
- 적절한 알고리즘을 사용해도 시간 초과가 날 경우 `Buffered Class`를 사용하여 I/O를 처리
  - 간단한 입출력에서는 Scanner 와 차이가 없지만 **입출력이 많아질 수록 그차이는 점점 커짐**
  - 차이
    - Bad 👎
      - Scanner : 입력 때 마다 필요한 자료형으로 변환하는 과정 필요
      - println : 출력이 발생할 때 마다 버퍼를 지우는 작업이 진행
    - Good 👍
      - BufferedWriter : 입력 버퍼를 저장 한 후 **데이터를 한번에 읽어**옴
      - BufferedReader : 출력 버퍼를 저장 한 후 **데이터를 한번에 출력**함

### 2 - 3 ) 인덱스에 의미 부여 하기 [ 해싱 기법 ]
- 배열에서 index는 일반적으로 **몇번째 데이터**인지를 기준으로 접근하는데 상황에 따라서는 **인덱스에 해싱 개념을 적용**해보자
  - 단순 위치가 아닌 **특정한 의미를 가지는 값으로 사용**하는 것
  - 인덱스를 단순히 순서로만 생각하지 말고 **문제 상황에 따라 다양한 의미로 변환해서 생각하는 것이 중요(해싱 기법)**

### 2 - 4 ) 나머지 연산의 분배 법칙
- 함정 문제로 정답을 OO로 나눈 나머지 값을 출력하는 문제가 있다.
  - 해당 문제의 의도
    - 자료형의 표현 범위를 넘지 않게 유도
    - 나머지 연산의 원리를 아는지 확인

#### 2 - 4 - 1 ) 나머지 연산의 분배 법칙
> 나머지 연산은 **나눗셈을 제외**한 "덧셈, 뺄셈, 곱셉"의 분배 법칙이 성립함
- **덧셈의 분배 법칙**
  - `(A + B) % C` 와 같다 `( A % C + B % C ) % C`
- **뺄셈의 분배 법칙**
  - `(A - B) % C` 와 같다 `( A % C - B % C ) % C`
- **ㅊ**
  - `(A * B) % C` 와 같다 `( A % C * B % C ) % C`
- **나눗셈의 분배 법칙**
  - ✅ **성립하지 않음**
```text
# PseudoCode

응답 값 = 1
for i = 1 to 50 do

    // 응답 값 *= i 👎 OverFlow 발생
    응답 값 = (응답값 * i) % 10_007 // 👍 곱셈의 분배 법칙으로 인해 OverFlow 방지
    
System.out.println( 응답 값 % 10_007 )
```

### 2 - 5 ) 정렬
- 배열의 경우 `Arrays.sort()` 내장 함수를 사용해서 쉽게 정렬이 가능하다.
  - 오름차순 : `Arrays.sort(new int[]{...})`
  - 내림차순 : `Arrays.sort(new Integer[]{...}, Collections.reverseOrder())`
    - 내림 차순에 사용되는 `Collections.reverseOrder()`를 사용하기 위해서는 기본형이 아닌 **Wrapper Class로 되어있어야 한다.**
    - Wrapper Class 제한이 있을 경우 음수로 변환 후 오름차순 정렬 후 다시 양수로 변환하는 등의 **다양한 접근 방식을 유연하게 떠올리는 것이 중요**

### 2 - 6 ) 다중 조건 정렬
> 참고 : [링크](https://github.com/edel1212/algorithm/blob/main/src/do_it/multiple_sort/ex01.java)
- 다중 조건 정렬을 처리할 떄는 `Comparable`과 `Comparator`가 있다.
- **Comparable** : 클래스 내부에서 자기 자신과 다른 객체 비교 기준 정의
  - 객체 스스로 기준을 가지고 있음.
  - 객체(구현체) 내부에서 내부 호출 사용
- **Comparator** : 외부 클래스/람다로 별도의 비교 기준 정의
  - 외부에서 다양한 기준을 넣어줌.
  - 정렬에 사용 될 Class로 사용 - 구현체 정렬 시 **인자 값으로 주입하여 사용**

### 2 - 7 ) 이차원 리스트
- **그래프를 표현**하는데 자주 사용됨
- 선언 후 메모리에 할당(초기화) 해주는 작업을 진행해 줘야함 ( IndexOutOfBoundException 발생 )
  - `for(int i = 0 ; i < 10 ; i ++) list.get(i).add( new ArrayList() ) `
- 데이터를 저장하거나 가져올 때는 **노드(Node)를 기준**으로 해서 저장 및 데이터를 가져 올 수 있다.


## 3 ) 문제 풀이
- 숫자의 합 구하기 [O]
