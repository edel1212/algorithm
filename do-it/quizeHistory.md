# ✍️ 문제 풀이
- 숫자의 합 구하기 - 11720번 [O]
- 평균 - 1546번 [O]
- 숫자의 합 구하기 - 11659번 [O]
- [✅] 구간 합 구하기 5 - 11660번 [X]
- [✅] 나머지 합 - 10986번 [X]
    - 재풀이
        - X
        - X
        - O
        - X : n개 중에서 2개를 선택하는 경우의 수 공식 햇갈림
        - X : 공식 또 틀림 나머지 계산 시 overflow 생각하기 (값의 범위를 확인)
        - X : 사용해야하는 아이디어는 떠올렸으나 구현하지 못함다
        - O
        - O
        - O
        - O
- [✅] 수들의 합 5 - 2018번 [X]
    - 재풀이
        - X
        - X :
            - 비교하려는 값이 단순 합산이 아닌 구간의 합으로 했어야 함
            - 투 포인터를 너무 한가지 방법으로 만 사용함 left와 right 둘 다 ++ 하는 방식으로 진행이 가능함 --, ++ 만 쓰는게 아님
        - O
        - X : 사용해야하는 알고리즘을 떠올리지 못 함
        - O
        - O
- [✅] 주몽 - 1940번 [O]
    - 재풀이
        - X : **정렬**을 빼고 진행함, 답을 찾았을 때 문제에 "고유한" 재료기에 양쪽 포인트에 증가, 감소 부분을 해주지 않음
- 좋다 - 1253번 [X]
    - 재풀이
        - X
        - X :
            - 투포인터의 기본 전제 조건 개념이 부족했음
            - 문제를 잘 읽어보는 습관 필요
        - O
        - X : "다른 수 두 개의 합"이라는 의도를 놓치고 풀의 함
        - X : 투포인터의 정렬의 중요성을 간과함, 그러므로 end 포인터의 위치를 잘못잡음 (입력값 기준으로 문제를 풀려고만 함)
        - X :
          - 사용해야 하는 알고리즘을 떠올리지 못함
          - 포인터의 기준을 제대로 잡지 못함 음수가 있을 수 있기이 `right = i -1`로 할 수 없음 
- DNA 비밀번호 - 12891번 [X]
    - 재풀이
        - O
        - X : 사용해야하는 알고리즘 못찾음 + 사용 알고리즘 이힌트를 받고도 구현하지 못함
        - X : 남은 범위 이동을 잘못 구현함
        - X : 슬라이딩 부분을 잘못 구현함
        - O
- 최솟값 찾기 - 11003번 [X]
    - 재풀이
        - X
        - X : 올바른 자료구조는 사용했으나 구현하지 못함
        - X : 비교 공식을 틀림 그림을 그려보자
        - X : 슬라이딩 윈도우로 미뤄졌을 경우 앞의 Index 처리 방법을 떠올리지 못함 + 효율적안 구현 방법을 생각해 내지 못함
        - O
- 스택 수열 - 1874번 [X]
    - 재풀이
        - O
        - X
        - X : 구현하지 못함
        - X : 구조는 잡았지만 구현하지 못함 - 스택 원리 한번 더 생각 및 문제를 확인하여 원리 파악하면 쉬움
        - X : 문제를 올바르게 이해하지 못함
        - O
- 오큰수 - 17298번 [X]
    - 재풀이
        - O
        - X
        - X : 풀지 못함
        - X : 한개의 자료구조를 가지고 할게 아닌 여러개를 쓸 생각을 하자 너무 1차원적 사고가 문제
        - X : 스택에는 무조건 값을 저장해야 한다는 고정관념을 버리자
        - O
- 카드2 - 2164번 [O]
- [✅] 절댓값 힙 - 11286번 [X] ( 😭문제와 입력, 출력 값을 잘 읽어보는 자세가 필요 )
    - 재풀이 [O, O]
- [✅]수 정렬하기 (버블 정렬 이용) - 2750번 [O]
- [✅]소트인사이드 (선택 정렬 이용) - 1427번 [X]
    - 재풀이
        - O
- ATM (삽입 정렬 이용) - 11399번 [X]
    - 재풀이
        - X : 삽입 대상의 값이 바뀐다는 것(쉬프트로 인해)을 인지하지 못함
        - X : 구현하지 못함
        - O
- K번째 수 (퀵 정렬 사용) - 11004번 [X]
    - 재풀이
        - X : 구현하지 못함
        - X : 구현하지 못함
- 수 정렬하기 2 (벙합 정렬 사용) - 2751번 [X]
    - 재풀이
        - X : 구현하지 못함
- 버블 소트 (병합 정렬 이용) - 1517번 [X]
    - 재풀이
        - X : 버블 정렬 구현에 문제가 있었음 + 계산식 및 위치 문제
- 수 정렬하기 3 (기수 정렬 이용) - 10989번 []
- 연결 요소의 개수 - 11724번 [X]
    - 재풀이
        - X
        - X
        - X : 개수 카운트 및 visited 방문 지정 위치를 틀림
        - X : 똑같이 또 틀림 사고 단위를 **정점 → 묶음**으로 바꿀 필요가 있음
        - O
- 신기한 소수 - 2023번 [O..?]
    - 재풀이
        - X
            - 소수 구분 메서드 구현하지 못함
            - dfs 부분 구현 못함
            - 초기 시작값 부분 이유를 몰랐음( 문제를 잘 읽어보는거 필요 )
        - X : 같은 이유로 구현하지 못함
- ABCDE - 13023번 [X]
    - 재풀이
        - X : 문제를 잘 읽어보자! 문제를 자세하게 읽어보지 않아 구현 알고리즘 선택 실수
- N과 M - 15649번 [X]
    - 재풀이
        - X : 아이디어를 생각해내지 못함
- N-Queen - 9663번 [X]
    - 재풀이
        - X : 아이디어를 생각해내지 못함
        - X : 대각선에 위치하는지 아는 방법은 2차원 배열을 1차원 배열로 압축했을 경우 대상의 행-행, 열-열 의 절대 값이 같으면 같은 대각선상에 있는 것
- 색종이 붙이기 - 17136번 [X]
    - 재풀이
        - X : 아이디어를 생각해냈으나 구현하지 못함
- [✅]DFS와 BFS - 1260번 [X]
    - 재풀이 [O]
- 미로 탐색 - 2178번 [X]
    - 재풀이
        - X
        - O
        - X : 구현하지 못함
        - X : 아이디어는 맞췄지만 구현을 잘못한 check를 따로 해야한다 생각함
- 트리의 지름 - 1167번 [X]
- 수 찾기 - 1920번 [X]
    - 재풀이
        - O
- 기타 레슨 - 2343번 [X]
    - 재풀이
        - X : 아이디어는 맞췄으나 이진 탐색 내부 용량 로직을 구현 못함
        - X : CD 사용 룡량 합산 부분 생각해 내지 못함, 이진 탐색 위치 지정 조건문 틀림
        - X : 용량 합산 조건식을 잘못함 조금 더 넒게 생각하자 조건식에서도 덧셈을 쓸 수 있음
        - O
- K번째 수 (이진 탐색) - 1300번 [X]
    - 재풀이
        - X : 문제의 아이디어를 이해하지 못하는 중
        - X : 이진 탐색 반복문 조건이 틀림, 아이디어 비교 조건문이 틀림
        - X : 아이디어를 떠올리지 못함
        - X : 카운트 조건식을 틀림
        - X : 결과 응답값 대상을 틀림
- [✅]동전 0 - 11047번 [O] : 문제 조건을 읽어보면 그리디 사용 여부를 알 수 있음
    - 재풀이
        - O
- 카드 정렬하기 - 1715번 [X]
    - 재풀이
        - O
- 수 묶기 - 1744번 [X] : 문제의 본질 케이스를 빼먹음 과 음수, 음수 일 경우 케이스 처리를 구현하지 못함
    - X : 두개씩 묶는 방법을 떠올리지 못함
- 회의실 배정  - 1931번 [X] : 문제 분석을 잘못함 시작 시간 기준 정렬 -> 사용시간 정렬로 생각했지만 종료시간을 빠르게(**더 많은 회의 횟수 확보**) 해야했음 (굳이 힙 사용 불필요함)
    - X : 그리디의 핵심을 이해하지 못함! (어떤게 최선인가 기준을 잘 잡자)
- 잃어버린 괄호  - 1514번 [X] : 아이디어를 생각해 내지 못함
- 소수 구하기 - 1929번 [X]
- 거의 소수 - 1456번 [X] : N제곱 부분을 제대로 구현하지 못함(overflow, 반복문 범위 지정)
- 소수&팰린드롬  - 1747번 [X]
- 제곱 ㄴㄴ 수  - 1016번 [X]
    - 재풀이
        - O
- 최소공배수  - 1934번 : 공식 `입력 값1 * 입력 값2 / 최대 공약수`
- 최대공약수  - 1850번 [X] : **"1이 반복되는 두 수의 최대공약수는, '두 수의 길이에 대한 최대공약수'만큼 1을 반복한 수이다."**
- 칵테일  - 1033번 [X] : 아예 풀지 못함 코드를 보고도 이해 못하는 중
- 특정 거리의 도시 찾기  - 18352 [X] : 방문 거리를 저장하는 배열을 사용할 수 있다!
    - 재풀이
        - O
- 효육적인 해킹  - 1325 [X] : 시간 초과와의 싸
    - 재풀이
        - O
- 이분 그래프  - 1707 [X] : 그래프의 형태를 확인하자 "이분 그래프(Bipartite Graph)의 정의 및 인접한 두 정점" 로 유추, 그래프가 쪼개졌을 경우도 생각야 함
    - 재풀이
        - O
        - X : DFS 방식 풀의 오답
- 물통  - 2251 [X] : 풀지 못함
    - 재풀이
        - X : 근접하게 풀의 했지만 경우의 수 물통 옮기기 사용에서 헷갈림
- 집합의 표현  - 1717 [X] : 문제를 이해하지 못해 풀지 못함
    - 재풀이
        - X : 마지막 비교 연산하는 대상 지정을 햇갈림
- 여행 가자  - 1976 [X]
    -  문제 접근을 잘못함 BFS로 풀려 했음 (union) - **경유해도 상관없고 재방문도 가능하기에 도달 가능성만 본다**가 포인트
    - 결과적으로 문제 이해를 제대로 못했었음 입력값은 인접 행렬 형식으로 주어진거 였음
    - 재풀이
        - O
        - X : find를 해야하는 대상 지정을 못함 (Union-Find 알고리즘의 본질을 생각하자 - 대장이 같으면 이어져 있어!!)
- 거짓말  - 1043 [X] : 파티일 경우 어떻게 union을 해줘야하는지 알지 못 함(union-find의 "이행성"을 사용하자)
    - 재풀이
        - X : 인접 행렬을 어떻게 구성해야 할지 진행 못하여 union-find 부분까지 구현하지 못 함
- 줄 세우기  - 2252
    - 재풀이
        - X : queue 에 입력차수 배열의 0일 어떤것 넣어야 하는지 헷갈림 (Loop 하면 된다.)
        - O
- 게임 개발  - 1516
    - 재풀이
        - X :
            - graph의 연관 관계 및 진입 차수 지정 값을 잘못 정함 (위상 정렬 그래프에서 $A -> B$ 간선은 **"A를 완료해야 B로 갈 수 있다"**는 뜻)
            - 위상 정렬의 구조는 잡았으나 소요 시간을 어떻게 구하는지 구현 하지 못함
        - O
- 최단경로 - 1753 [X] : 문제를 BFS 방식으로 접근함 ! 다익스라는 visit 사용법과 PriorityQueue를 사용해야 함!
    - 재풀이
        - O
- 최소비용 구하기  - 1916 [X] : PQ에 저장하는 가중치를 한개의 경로만 넣어 저장함, PQ 메모리 최적화 하지 않음 조건문으로 무조건 offer() 안하게 할 수있음
- K번째 최단경로 찾기  - 1854 [X] : 최단 경로를 우선순위 큐에 넣고 내림 차순으로 활용하는 아이디어를 떠올리지 못함 (모든 경로를 저장한 후 찾는다가 포인트)
    - 재풀이
        - X : allCityDistance를 어떻게 초기화 할지 기억해내지 못함, allCityDistance의 사용할 제네릭을 너무 어렵게 생각함
        - X : 최단 거리 값의 init을 고민함 (전광판이기에 필요 없음, 단 -> 다익스트라 시작 0 값은 초기화 필요 ) \\ 시간에 대해 잘 못 이해함 다익스트라는 항상 **"시작점으로부터의 거리"**를 저장이 **포인트**
- 타임머신  - 11657 [X] : 가중치가 음수이거나 0이 라는 것은 무한히 뒤로 간다는게 아니라 그만큼 **시간을 단축 할 수 있단 의미**
    - 재풀이
        - X : 업데이트 조건식을 잘못 세워서 구현함
        - O
- 오민식의 고민  - 1219 [X] : 구현하는 방법을 생각하지 못함
    - 재풀이
        - X : 기본 벨만-포크와 차이점을 헷갈림 해당 문제의 포커싱은 어떻게 하면 더 높은 값을 얻느냐 이기에 최단 거리 초기화 및 저장 방법이 다름  !
- 플로이드 - 11404 [X] : 초가깂 init 및 3중 반복문의 `K, S, E` 값을 무엇으로 할지 정하지 못했음- 회의실 배정  - 1931번 [X] : 문제 분석을 잘못함 시작 시간 기준 정렬 -> 사용시간 정렬로 생각했지만 종료시간을 빠르게(**더 많은 회의 횟수 확보**) 해야했음 (굳이 힙 사용 불필요함)
    - X : 그리디의 핵심을 이해하지 못함! (어떤게 최선인가 기준을 잘 잡자)
- 잃어버린 괄호  - 1514번 [X] : 아이디어를 생각해 내지 못함
- 소수 구하기 - 1929번 [X]
- 거의 소수 - 1456번 [X] : N제곱 부분을 제대로 구현하지 못함(overflow, 반복문 범위 지정)
- 소수&팰린드롬  - 1747번 [X]
- 제곱 ㄴㄴ 수  - 1016번 [X]
    - 재풀이
        - O
- 최소공배수  - 1934번 : 공식 `입력 값1 * 입력 값2 / 최대 공약수`
- 최대공약수  - 1850번 [X] : **"1이 반복되는 두 수의 최대공약수는, '두 수의 길이에 대한 최대공약수'만큼 1을 반복한 수이다."**
- 칵테일  - 1033번 [X] : 아예 풀지 못함 코드를 보고도 이해 못하는 중
- 특정 거리의 도시 찾기  - 18352 [X] : 방문 거리를 저장하는 배열을 사용할 수 있다!
    - 재풀이
        - O
- 효육적인 해킹  - 1325 [X] : 시간 초과와의 싸
    - 재풀이
        - O
- 이분 그래프  - 1707 [X] : 그래프의 형태를 확인하자 "이분 그래프(Bipartite Graph)의 정의 및 인접한 두 정점" 로 유추, 그래프가 쪼개졌을 경우도 생각야 함
    - 재풀이
        - O
        - X : DFS 방식 풀의 오답
- 물통  - 2251 [X] : 풀지 못함
    - 재풀이
        - X : 근접하게 풀의 했지만 경우의 수 물통 옮기기 사용에서 헷갈림
- 집합의 표현  - 1717 [X] : 문제를 이해하지 못해 풀지 못함
    - 재풀이
        - X : 마지막 비교 연산하는 대상 지정을 햇갈림
- 여행 가자  - 1976 [X]
    -  문제 접근을 잘못함 BFS로 풀려 했음 (union) - **경유해도 상관없고 재방문도 가능하기에 도달 가능성만 본다**가 포인트
    - 결과적으로 문제 이해를 제대로 못했었음 입력값은 인접 행렬 형식으로 주어진거 였음
    - 재풀이
        - O
        - X : find를 해야하는 대상 지정을 못함 (Union-Find 알고리즘의 본질을 생각하자 - 대장이 같으면 이어져 있어!!)
- 거짓말  - 1043 [X] : 파티일 경우 어떻게 union을 해줘야하는지 알지 못 함(union-find의 "이행성"을 사용하자)
    - 재풀이
        - X : 인접 행렬을 어떻게 구성해야 할지 진행 못하여 union-find 부분까지 구현하지 못 함
- 줄 세우기  - 2252
    - 재풀이
        - X : queue 에 입력차수 배열의 0일 어떤것 넣어야 하는지 헷갈림 (Loop 하면 된다.)
        - O
- 게임 개발  - 1516
    - 재풀이
        - X :
            - graph의 연관 관계 및 진입 차수 지정 값을 잘못 정함 (위상 정렬 그래프에서 $A -> B$ 간선은 **"A를 완료해야 B로 갈 수 있다"**는 뜻)
            - 위상 정렬의 구조는 잡았으나 소요 시간을 어떻게 구하는지 구현 하지 못함
        - O
- 최단경로 - 1753 [X] : 문제를 BFS 방식으로 접근함 ! 다익스라는 visit 사용법과 PriorityQueue를 사용해야 함!
    - 재풀이
        - O
- 최소비용 구하기  - 1916 [X] : PQ에 저장하는 가중치를 한개의 경로만 넣어 저장함, PQ 메모리 최적화 하지 않음 조건문으로 무조건 offer() 안하게 할 수있음
    - 재풀이
        - O
- K번째 최단경로 찾기  - 1854 [X] : 최단 경로를 우선순위 큐에 넣고 내림 차순으로 활용하는 아이디어를 떠올리지 못함 (모든 경로를 저장한 후 찾는다가 포인트)
    - 재풀이
        - X : allCityDistance를 어떻게 초기화 할지 기억해내지 못함, allCityDistance의 사용할 제네릭을 너무 어렵게 생각함
        - X : 최단 거리 값의 init을 고민함 (전광판이기에 필요 없음, 단 -> 다익스트라 시작 0 값은 초기화 필요 ) \\ 시간에 대해 잘 못 이해함 다익스트라는 항상 **"시작점으로부터의 거리"**를 저장이 **포인트**
        - O
- 타임머신  - 11657 [X] : 가중치가 음수이거나 0이 라는 것은 무한히 뒤로 간다는게 아니라 그만큼 **시간을 단축 할 수 있단 의미**
    - 재풀이
        - X : 업데이트 조건식을 잘못 세워서 구현함
        - O
- 오민식의 고민  - 1219 [X] : 구현하는 방법을 생각하지 못함
    - 재풀이
        - X : 기본 벨만-포드와 차이점을 헷갈림 해당 문제의 포커싱은 어떻게 하면 더 높은 값을 얻느냐 이기에 최단 거리 초기화 및 저장 방법이 다름
        - X : 벨만-포드 알고리즘을 기억하지 못함
- 플로이드 - 11404 [X] : 초가깂 init 및 3중 반복문의 `K, S, E` 값을 무엇으로 할지 정하지 못했음
    - 재풀이
        - O
- 경로 찾기 - 11403 [X] : S -> K && K -> E 아 연결 되어 있다면, S -> E 도 연결 되어있다 (why? S -> E 가 연결되어 있다면 사이에 K가 있다면 중간은 다 연결되어 있기 떄문임)
    - 재풀이
        - X :
            - 오답 이유 ? : 알고리즘의 원리는 맞게 생각하 였으나 인접 행렬에 대한 인식이 부족했음 위치가 같을 경우로 진행 완했음
                - 잘못된 예시 : `if(dist[S][K] ==  dist[K][E]) dist[S][E] = 1;`
            - 해답 :  "S -> E 중간에 K가 있다면 S -> K와 K -> E 도 **최단거리**이다", "S -> E로 가는 길이 이미 있거나, K를 거쳐 갈 수 있어도 해당 길은 경로가 있다."
- 케빈 베이건의 6단계 법칙 - 1389 [X] : 플로이드 워셜 알고리즘의 기본 초기 init을 까먹음 + 그래프가 양방향이라는 것을 간과함
- 최소 스패닝 트리 - 1197 [X] : `union-find` 알고리즘을 정상적으로 구현하지 못함 + 반복 횟수 카운트의 위치를 잘못 카운트하여 진행함 카운트는 사이클이 없을 때 해야한다.
    - 재풀이
        - O : PriorityQueue를 사용했지만 굳이 해당 자료 구조를 쓸 필요가 없음 비효율적 -> `Array.sort`쓰자!
- 다리 만들기2 - 17472 [X] : 구현하지 못함
    - 재풀이
        - X :
            - 오답 이유 ? :
                - BFS를 통해 섬의 번호를 부여할 때 초기 시작 시 방문 체크를 해주지 않았음
                - 브루트 포스 (다리를 건설)
                    - 조건식을 잘몾 잡음 BFS를 통해 섬의 번호를 매겨 놓고 `maps[i][j] ==1`로 하여 1번 섬만 확인함
                    - 인자 값 섬 번호를 빼먹음 (다리가 나 자신과 만날 때 예외처리 필요하기에)
                    - 한간씩 전진을 잘못 생각함 `++`가 아닌 상하좌우 변수를 활용했어야 함
                    - 우선순위 큐 주입 전 조건식을 생각하자 그냥 막넣는게 아닌 바다가 아닌 섬에 도착 했을 경우임
                    - 우선순위 큐 주입 시 좌료를 주입함 (시작노드, 종료 노드) 주입해야 함
        - X :
            - 오답 이유 ? :
                - 브루트 포스 (다리를 건설)
                    - 지도 범위 조건식을 틀림
                        - 잘못된 예시 : `if(nr < 0 || nc < 0 || nr > N || nc > M) break;`
                    - 땅이 아닐 경우에 대한 조건식을 틀림 --> 땅을 만나면 다리가 완성된걸로 판단하고 새로운 조건식을 진행해야한다!
                        - 잘못된 예시 : `if(map[nr][nc] != 0) break;`
- 불우이웃돕기 - 1414 [X] : 최소 신장 트리의 핵심 `간선 개수 == N - 1`를 망각함, 간선들을 담을 자료구조를 제대로 선택하지 못함
    - 재풀이
        - X :
            - 오답 이유 ? :
            - 초기 graph를 init 할 때 인접행렬 구조라는 걸 헷갈림 PriorityQueue 구조기에 이전 예제들과 헷갈림
            - 랜선의 길이가 0일 경우 그래프가 연결될 필요가 없는데 연결 시켜 버림
            - 해결 방안 : 엣지 기반 PriorityQueue 값에 대해 다른 코드와 헷갈리지 말자
        - O
- 트리의 부모 찾기 - 11725 [X] : 트리의 간선의 개수는 `N-1`이 이다!!!
    - 재풀이
        - O
        - X :
            - 오답 이유 ? : 초기 tree 데이터 주입 시 단방향으로 만듬 **(특별한 문제에 조건이 없을 경우 트리틑 양방향으로 만들자)**
- 트리 - 1068 [X] : DFS 개념을 잘 모르는 것으로 확정..
    - 재풀이
        - O
- 문자열 집합 - 14425 [X] : 트라이의 핵심은 Class의 구조다
    - 재풀이
        - X :
            - 오답 이유 ? : 트라이 구조를 잡지 못해 풀지 못함
- 트리 순회 - 1991 [X] : 풀이 방법을 생각해 내지 못함 , 전위 순회, 중위 순회, 하위 순회 개념을 몰랐음
    - 재풀이
        - X :
            - 오답 이유 ? : 이진 트리를 배열 구조로 구현하지 못함
            - 값 주입 시 `char -> int` 로 변환하는걸 생각하지 못함
- 구간 합 구하기 (세그먼트 트리) - 2042
    - 재풀이
        - O
        - O
- 최솟 값 (세그먼트 트리) - 10868
    - 풀이 결과 [X] :
        - 최솟 값을 구할 경우 트리의 초기 값 세팅 시 최대 값을 넣어줘야하는 부분을 생각하지 못함
        - 값을 정의 할때 기준을 자식 노드로 잡고 Loop를 돌리면서 부모 노드를 찾으러함 -> 부모 노드 기준으로 자식을 찾아서 진행 했어야 했음
        - 값을 추출할 때 최솟 값을 비교하는 대상을 잘못 잡음 각각의 노드들을 비교하면서 최솟 값을 찾았어야 했으나 노드 각각 비교하고 0으로 다시 초기화 하는 잘못된 로직 구현
    - 재풀이
        - O
- 구간의 곱 구하기 (세그먼트 트리) - 11505
    - 재풀이
        - O
- 이항의 계수 1 - 11050
    - 재풀이
        - X :
            - 오답 이유 ? :
                - 점화식 배열 초기화 방법을 몰랐음
                - 1단 반복문
                - `0 <= N` 까지 필요 DP에서의 0은 중요한 겂 아무것도 고르지 않았을 때를 의미
                - 점화식 도출에대한 반복문 구조를 잡지 못함
                - **효율성을 위함** 양 끝 벽(0번째, i번째)은 이미 1로 채워놨으니까, 2행부터 시작해서 **그 사이의 빈칸(1 ~ i-1)만 채우는 것이 효율적**
                - 직각 삼각형을 생각하면 된다, **(벽면을 제외한 내부만 계산하여 채운다)** ✅가장 아래 Row는 벽이 없음
    - O
- 이항의 계수 2 - 11051
    - 재풀이
        - O
- 부녀회장이 될테야 - 2775 [X] : DP 배열 초기화를 못함 ( 각 상황에 맞는 초기화 방벙을 사용해야함 ), 점화식 도출을 하지 못함
    - 재풀이
        - O
- 다리 놓기 - 1010 [X] : 문제를 읽어보고 생각의 전환이 "겹치지 않게"라는 포인트가 있었으므로 조합 사용이 가능한 문제였음
- 조약돌 꺼내기 - 13251 [X] : DP 배열의 타입이 왜 `double`로 해야하는지 이해하지 못함, DP배열을 2번써서 문제를 풀 수 있단걸 몰랐음 ( 같은 색의 돌 뽑을 경우의 수 / K 번 뽑을 경우의 수 )
    - 재풀이
        - O
- 조약돌 뽑기 - 13251
    - 재풀이
        - X :
            - 오답 이유 ? :
                - 분모(parent)에 대한 명확한 의도를 파악 못함 - (전체 개수에서 내가 뽑으려는 방법의 조합)  
                - 분자(children) 조건식 이해 못함 - 뽑으려는 수 보다 조약돌이 적으면 뽑을 수 없게 처리 (  `stones[i] >= K`  )
                - 분자(children)을 누적 합 이유에 대해서 이해 못함 - ( 각각의 돌의 총 개수를 구하는 것임 )
- 순열의 순서 - 1722 
